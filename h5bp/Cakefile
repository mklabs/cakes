# `cake` is a simplified version of [Make](http://www.gnu.org/software/make/)
# ([Rake](http://rake.rubyforge.org/), [Jake](http://github.com/280north/jake))
# for CoffeeScript. You define tasks with names and descriptions in a Cakefile,
# and can call them from the command line, or invoke them from other tasks.
#
# Running `cake` with no arguments will print out a list of all the tasks in the
# current directory's Cakefile.
#
# TODO:
# * break the script in smaller parts
#
#   * js
#   * css
#   * html
#   * img
#   * lint
#

# External dependencies.
fs              = require 'fs'
path            = require 'path'
util            = require 'util'
{spawn, exec}   = require 'child_process'
{EventEmitter}  = require 'events'
vm              = require 'vm'
colors          = require 'colors'
prompt          = require 'prompt'
mkdirp          = require 'mkdirp'
uglify          = require 'uglify-js'
cssmin          = require 'clean-css'
htmlmin         = require 'html-minifier'
coffee          = require 'coffee-script'
optparse        = require 'coffee-script/lib/optparse'
winston         = require 'winston'
eyes            = require 'eyes'
config          = require './conf/default'
helper          = require './helper'
levels          = winston.config.cli.levels

base = process.cwd()

# options parsing, needs this to be able to parse command line arguments and used them outside of a cake task
# mainly for the loglevel options
switches = [
  ['-l', '--loglevel [level]', 'What level of logs to report. Values → ' + Object.keys(levels).join(', ') + ' or silent'],
  ['-o', '--output [DIR]', 'directory for the createproject task']
]

oparse = new optparse.OptionParser switches
options = oparse.parse process.argv.slice(2)

debugger

# still call option to make cake keep track of these options too
option.apply this, opt for opt in switches

if options.loglevel and options.loglevel isnt 'silent' and levels[options.loglevel] is undefined
  throw new Error('Unrecognized loglevel option: ' + options.loglevel + ' \n instead of → ' + Object.keys(levels).join(', '))

# Extend a source object with the properties of another object (shallow copy).
extend = exports.extend = (object, properties) ->
  for key, val of properties
    object[key] = val
  object


# merge the local config with global object for this module, 
# so that interpolation works as expected (of course, config should not redefine global variable)
extend global, config

# the event emitter used along tasks to handle some asynchronous stuff, gem for global EventEmitter
gem = new EventEmitter

# setup logger
log = new winston.Logger
  transports: [
    new winston.transports.Console({ level: options.loglevel || 'silly' })
  ]

log.inspector = eyes.inspector
  stream: null
  styles:                 # Styles applied to stdout
    all:     null,        # Overall style applied to everything
    label:   'underline', # Inspection labels, like 'array' in `array: [1, 2, 3]`
    other:   'inverted',  # Objects which don't have a literal representation, such as functions
    key:     'grey',      # The keys in object literals, like 'a' in `{a: 1}`
    special: 'grey',      # null, undefined...
    number:  'blue',      # 0, 1, 2...
    bool:    'magenta',   # true false
    regexp:  'green'      # /\d+/

log.inspect = (o) ->
  result = log.inspector(o)
  log.data line for line in result.split('\n')

log.cli()

# ### task monkey-patch
#
# to provide a tasks-scopped EventEmitter to enable some async stuff and task ordering
#
_task = global.task

# internal _tasks cache, stored as `taskname: status` where status turns false
# once the end event is emitted
_tasks = {}

task = (name, description, action) ->

  description = description.grey
  _task name, description, (options) ->
    em = new EventEmitter()
      # provide a few logging helpers
      .on('error', (err) -> log.error 'error occured'.red.bold; error err)
      .on('log', log.input.bind log, "#{name} » ".magenta)
      .on('data', log.inspect.bind log)
      .on('end', (results) ->
        log.info  "✔ end:#{name}".green
        gem.emit "end:#{name}", results
        _tasks[name] = 'done'
      )

    state = _tasks[name]

    # emit the end event and prevent action call if the task is
    # already done
    return gem.emit "end:#{name}" if state is 'done'

    # set the task state to pending, will turn done once the task emiter
    # emit the end event
    _tasks[name] = 'pending'

    log.verbose "start #{name}  » ".grey
    # invoke the task if the task is unknown yet
    action.call @, options, em unless state


# error handler, usage:
#
#     return error err if err
#
#     return error new Error(':((') if err
error = (err) ->
  log.error '  ✗ '.red + (err.message || err).red
  process.exit 1

#
# Autoload tasks in tasks/
#
fs.readdirSync(path.join(__dirname, 'tasks'))
  .filter((file) -> fs.statSync(path.join(__dirname, 'tasks', file)).isFile())
  .forEach (file) ->
    script = fs.readFileSync path.join(__dirname, 'tasks', file), 'utf8'
    # tasks may be written in pure JS or coffee. Take care of coffee compile if needed.
    script = if /\.coffee$/.test(file) then coffee.compile script else script
    # merge the globals for console, process etc
    context = extend {}, global
    # and setup a few local variable to be available in context
    extend context, 
      task: task
      require: require
      error: error
      gem: gem
      __filename: file
      __dirname: path.dirname path.join(__dirname, 'tasks', file)

    vm.runInNewContext script, context, file


# ## JS tasks

# ### js.main.concat
#
# Concatenates the JS files in dir.js. depends on mkdirs
task 'js.main.concat', 'Concatenates the JS files in dir.js', (options, em) ->

  invoke 'mkdirs'

  concat = (output) ->
    output = new Buffer output.join('\n\n')
    fs.writeFile path.join(__dirname, "#{dir.intermediate}", "#{dir.js}", 'script-concat.js'), output, (err) ->
      return error err if err
      em.emit 'log', 'script-concat.js just concat...'.grey
      em.emit 'end', true

  handle = (files) ->
    em.emit 'log', 'Concatenating Main JS scripts...'

    helper.fileset "#{dir.js.main}/plugins.js #{dir.js.main}/#{file.root.script}", '', (err, files) ->
      output = []
      remaining = files.length
      for file in files then do (file) ->
        fs.readFile file, (err, body) ->
          return error err if err
          output.push body

          concat(output) if --remaining is 0 


  gem.once 'end:mkdirs', handle

# ### js.mylibs.concat
#
# Concatenates the JS files in dir.js.mylibs. depends on mkdirs
#
task 'js.mylibs.concat', 'Concatenates the JS files in dir.js.mylibs', (options, em) ->

  invoke 'mkdirs'

  concat = (output) ->
    output = new Buffer output.join('\n\n')
    fs.writeFile path.join(__dirname, "#{dir.intermediate}", "#{dir.js.mylibs}", 'mylibs-concat.js'), output, (err) ->
      return error err if err
      em.emit 'log', 'mylibs-concat.js just concat...'.grey
      em.emit 'end', true

  gem.once 'end:mkdirs', (files) ->
    em.emit 'log', "Concatenating JS libraries in #{dir.js.mylibs}".grey

    process.chdir path.join(__dirname, "#{dir.intermediate}")
    helper.fileset "#{dir.js.mylibs}/**/*.js", "#{file.default.js.bypass}", (err, files) ->
      return error err if err

      output = []

      return concat(output) unless files.length

      remaining = files.length
      for file in files then do(file) ->
        fs.readFile file, (err, body) ->
          return error err if err
          output.push body
          concat(output) if --remaining is 0


# ### js.scripts.concat
#
# Concatenating library file with main script file
#
# Calculates an md5 checksum, prefix the script name, and copy over to `#{dir.publish}/#{dir.js}/`
#
#     publish/js/e816baa.scripts-concat.min.js
#
task 'js.scripts.concat', 'Concatenating library file with main script file', (options, em) ->

  invoke 'js.main.concat'
  invoke 'js.mylibs.concat'

  concat = (source) ->
    concat.remaining = concat.remaining or= 0
    concat.remaining++

    return ->
      return if --concat.remaining
      helper.fileset "#{base}/#{dir.intermediate}/#{dir.js}/**-concat.js", (err, files) ->
        return error err if err

        em.emit 'log', 'Concatenating library file with main script file'.grey
        helper.concat files, (err, buffers) ->
          return error err if err

          em.emit 'log', "Writing to #{dir.intermediate}/#{dir.js}/scripts-concat.min.js".grey

          filename = "scripts-concat.min.js"
          from = "#{dir.intermediate}/#{dir.js}/#{filename}"
          output = buffers.map (buffer) ->
            return buffer.toString()

          fs.writeFile path.join(base, from), output.join('\n\n'), (err) ->
            return error err if err
            em.emit 'log', "File ✔ #{from}".grey

            em.emit 'log', 'Calculating checksum...'.grey


            helper.checksum path.join(base,from), (err, md5) ->
              return error err if err

              em.emit 'log', "✔ md5 is #{md5} for file #{from}"
              # now copy over the file to #{dir.js}/#{script.sha}.js
              md5 = md5.substring 0, hash.length
              to = "#{dir.intermediate}/#{dir.js}/#{md5}.#{filename}"

              # set the global script.js for future reference in usemin
              global.scripts = { js: "#{md5}.#{filename}" }

              em.emit 'log', "now copy over the file to #{to}"
              return helper.copy path.join(base, from), path.join(base, to), (err) ->
                return error err if err
                em.emit 'log', "✔ Copy done » #{to}"

                em.emit 'log', 'Minify the output now...'
                invoke 'js.all.minify'


  gem.on 'end:js.main.concat', concat('main')
  gem.on 'end:js.mylibs.concat', concat('mylibs')

  gem.on 'end:js.all.minify', em.emit.bind(em, 'end')


# ### js.mylibs.concat
#
# Minifies the scripts.js files in #{dir.intermediate}/#{dir.js}. depends on mkdirs
#
task 'js.all.minify', "Minifies the *-concat.js files in #{dir.intermediate}/#{dir.js}", (options, em) ->

  gem.once 'end:mkdirs', (result) ->
    em.emit 'log', 'Minifying scripts'.grey

    dirname = path.join dir.intermediate, dir.js
    process.chdir path.join(__dirname, dirname)
    helper.fileset "**-concat.min.js", (err, files) ->
      return error err if err

      remaining = files.length
      for file in files then do (file) ->
        fs.readFile file, (err, body) ->
          jsp = uglify.parser
          pro = uglify.uglify

          ast = jsp.parse body.toString()
          ast = pro.ast_mangle ast
          ast = pro.ast_squeeze ast
          code = new Buffer pro.gen_code(ast)

          fs.writeFile file, new Buffer(code), (err) ->
            return error err if err
            em.emit 'log', "Uglified #{file}".grey
            em.emit 'end', files if --remaining is 0

  invoke 'mkdirs'

# ## jshint
# run the `dir.js` folder through jshint with default options. Exits and reports in case of lint errors.
#
# Run separately
task 'jshint', 'jshint task, run jshint on any non min.js file in dir.js', (options, em) ->
  helper.fileset "#{dir.source}/#{dir.js}/", "**/*.min.js #{dir.source}/#{dir.js.libs}", (err, files) ->
    return error err if err
    exec 'jshint ' + files.join(' '), (err, stdout, stderr) -> 
      return em.emit 'log', '  ✔ Congrats! Lint Free!'.green unless err

      if err.message is 'Command failed: '
        em.emit 'log', [
          "jshint returns the following errors \n".grey
          stdout.split('\n').map((line) -> return "  ✗ #{line}").join('\n').grey
        ].join('\n')

      return error err if err

# ## csslint
# run the `dir.css` folder through csslint with default options. Reports in case of lint errors.
#
# Run separately
task 'csslint', 'csslint task, run csslint on dir.css and ommit *.min.css one', (options, em) ->
  helper.fileset "#{dir.source}/#{dir.css}/", "**/*.min.css", (err, files) ->
    return error err if err
    for file in files then do (file) ->
      exec 'csslint ' + file, (err, stdout, stderr) -> 
        return em.emit 'log', "  ✔ Congrats! Lint Free! --> #{file}".green if stdout.match(/no\serrors/i)

        em.emit 'log', [
          "  ✗ csslint returns the following errors".red
          stdout.split('\n').map((line) -> return "    #{line}").join('\n').grey
        ].join('\n')


# ## CSS tasks

# ### css.concat
#
# Concat the CSS files depending on the @imports in your file.root.stylesheet
#
# `@import` should be fortmated like so
#
#     @import url('style.bar.css')
#     @import url("style.foo.css")
#
task 'css.concat', 'Concat the CSS files depending on the @imports in your file.root.stylesheet', (options, em) ->

  invoke 'mkdirs'

  gem.once 'end:mkdirs', ->
    em.emit 'log', 'Copy source file to intermediate directory'
    from = path.join dir.source, dir.css, file.root.stylesheet
    to = path.join dir.intermediate, dir.css, file.root.stylesheet
    return em.emit 'copy', from, to

  # called once the source to intermediate copy is done
  em.on 'copy', (from, to) ->
    em.emit 'log', 'Concatenating any @imports'

    # replace imports with h5bp-import tags (part 1) this one wraps @media types
    file = fs.readFile path.join(base, to), 'utf8', (err, body) ->

      # go sync during the process of replace to ease the process
      body = body.replace /@import url\([^\)]+\)/gi, (match) ->
        file = match.match(/@import url\(([^\)]+)\)/)?[1].replace(/['|"]/g, '')
        filepath = path.join base, dir.intermediate, dir.css, file

        # test if the url property is valid and match an actual file in the repo
        ok = path.existsSync filepath
        return error new Error("@import-ed #{filepath} does not exist") unless ok

        em.emit 'log', "replacing #{match} with #{file} content"
        return "/* h5bp-import --> #{file} */\n" + fs.readFileSync filepath, 'utf8'

      # now minify the whole css file, done using clean-css
      # may just opt to use yuicompressor instead by spawning a java process
      # (make it configurable)
      em.emit 'log', "Minify #{to} file..."
      body = cssmin.process body
      em.emit 'log', 'Done'.green
      # write the file to the intermediate dir
      to = path.join base, to

      checksum = helper.checksum(body).substring 0, hash.length

      em.emit 'log', "Cheskum for this file is #{checksum}"
      to = to.replace(/style\.css/, "#{checksum}.style.min.css")

      # set the global style.css for future reference in usemin
      global.style = { css: to.split('/').reverse()[0] }

      em.emit 'log', "Write the min css file to #{to}"
      fs.writeFile to, body, (err) ->
        return error err if err
        em.emit 'end', body

# ## img optimization tasks

# ### img.optimize
# mainly done using optipng and  by spawning child process, so you'll need
# optipng in yout PATH for this to work
#
# no jpg optimization for now
task 'img.optimize', 'Run optipng', (options, em) ->

  invoke 'mkdirs'

  gem.once 'end:mkdirs', ->
    em.emit 'log', 'Optimizing images...'
    em.emit 'log', 'This part might take a while. But everything else is most likely already done.'

    em.emit 'log', 'Run optipng on the .png files'

    # check that we have actual png files before runing optipng
    helper.fileset "#{base}/#{dir.intermediate}/#{dir.images}/*.png", (err, files) ->
      return erorr err if err

      # prevent optipng from returning with error if no files to process
      return em.emit 'end' unless files.length

      # run optipng with default options (make this configurable)
      exec "optipng #{base}/#{dir.intermediate}/#{dir.images}/*.png", (err, stdout, stderr) ->
        return error new Error( (stderr || stdout).trim().split('\n').join('\n  » ') ) if err

        em.emit 'log', '\n  » ' + stdout.trim().split('\n').join('\n  » ').grey, '\n\n'
        em.emit 'end'

# ## img.ref
#
# should we do this before, or after img.optimization?
task 'img.rev', 'handle the automatic revving of image filenames', (options, em) ->
  invoke 'img.optimize'

  gem.once 'end:img.rev', (chk) ->
    em.emit 'log', chk

  gem.once 'end:img.optimize', ->
    em.emit 'log', 'Going to rev image filenames'

    helper.fileset "#{base}/#{dir.intermediate}/#{dir.images}/*.png", (err, files) ->
      return error err if err

      checksums = global.checksums = []

      return em.emit 'end' unless files.length
      remaining = files.length
      for file in files then do (file) ->
        helper.checksum file, (err, checksum) ->
          checksum = checksum.substring 0, hash.length
          em.emit 'log', "#{file} checksum is #{checksum}"

          filename = file.split('/').reverse()[0]
          checksum = "#{checksum}.#{filename}"
          em.emit 'log', "copying #{filename} to #{checksum}"

          helper.copy file, file.replace(filename, checksum), (err) ->
            return error err if err

            # once copy done, also keep reference to filename -> sha, to use in `usemin`
            # probably not the best way to do this, relying on module-scoped variable
            checksums.push(checksum)
            em.emit 'end', checksums if --remaining is 0


# ## Html tasks
#
# tasks related to html manipulation such as cleaning
# and updating script/css references, html minification and so on


# ### usemin
task 'usemin', 'Replaces references to non-minified scripts/styles', (options, em) ->
  remaining = 0
  handle = ->
    remaining++
    return ->
      return unless --remaining is 0
      em.emit 'log', 'Switching to minified js files...'

      process.chdir path.join(base, dir.intermediate)
      helper.fileset "#{file.pages.default.include}", (err, pages) ->
        return error err if err

        pagesCount = pages.length
        for page in pages then do (page) ->

          # again go sync during the replace process
          fs.readFile page, 'utf8', (err, body) ->
            return error err if err

            em.emit 'log', 'switch from a regular jquery to minified'
            body = body.replace /jquery-(\d|\d(\.\d)+)\.js/g, (file, version) ->
              return "jquery-#{version}.min.js"

            em.emit 'log', 'switch any google CDN reference to minified'
            body = body.replace /(\d|\d(\.\d)+)\/jquery\.js/g, (match, version) ->
              return "#{version}/jquery.min.js"

            em.emit 'log', 'Kill off those versioning flags: ?v=2'
            body = body.replace /\?v=\d+/g, (match) ->
              return ""

            em.emit 'log', 'Remove favicon.ico reference if it is pointing to the root'
            body = body.replace /<link rel=["']shortcut icon["'] href=["']\/favicon\.ico["']>/g, (match) ->
              return ""

            em.emit 'log', "Update the HTML to reference our concatenated script file: #{scripts.js}"
            body = body.replace /<!-- scripts concatenated[\d\w\s\W]*<!-- end scripts -->/gm, ->
              return "<script defer src=\"#{dir.js}/#{scripts.js}\"></script>"

            em.emit 'log', "Update the HTML with the new css filename: #{style.css}"
            body = body.replace /<link rel=["']?stylesheet["']?\shref=["']?(.*)\/style.css["']?\s*>/gm, (match, prefix) ->
              return "<link rel=\"stylesheet\" href=\"#{prefix}/#{style.css}\">"

            em.emit 'log', "Update the HTML with the new img filenames: ", checksums.join(' - ')

            checksums.forEach (file) ->
              parts = file.split('.')
              filename = parts[1..].join('.')
              em.emit 'log', "update html files #{filename} with #{file}"
              reg = new RegExp(filename)
              body = body.replace /<img.+src=['"](.+)["'].+\/>/gm, (match, img) ->
                em.emit 'log', 'replace ', img, ' on -->', match
                return if reg.test img then match.replace(filename, file) else match

            fs.writeFile page, body, (err) ->
              return error err if err
              em.emit 'log', "#{page} now referencing minified files"
              em.emit 'end' if --pagesCount is 0


  gem.on 'end:js', handle()
  gem.on 'end:css', handle()
  gem.on 'end:img', handle()

  invoke 'js'
  invoke 'css'
  invoke 'img'


task 'usecssmin', 'update rev img in css files', (options, em) ->

  invoke 'css'
  invoke 'img'

  remaining = 0
  handle = ->
    remaining++
    return ->
      return unless --remaining is 0

      helper.fileset "#{base}/#{dir.intermediate}/#{dir.css}/**.css", (err, styles) ->
        return error err if err

        ln = styles.length
        for style in styles then do(style) ->
          fs.readFile style, 'utf8', (err, body) ->
            return error err if err

            em.emit 'log', "Update the CSS with the new img filenames: ", checksums.join(' - ')
            checksums.forEach (file) ->
              parts = file.split('.')
              filename = parts[1..].join('.')
              em.emit 'log', "updating #{filename} with #{file}"
              body = body.replace new RegExp(filename, 'g'), file



            fs.writeFile style, body, (err) ->
              return error err if err
              em.emit 'log', "#{style} now referencing rev files"
              em.emit 'end' if --ln is 0



  gem.once 'end:css', handle()
  gem.once 'end:img', handle()

# ## html tasks

# ### manifest
# stumb method for now.

task 'manifest', 'Manifest stuff', (options, em) ->

# ### htmlclean
#
# using the fantastic html minifier tool by kangax:: https://github.com/kangax/html-minifier
task 'htmlclean', 'Peforms basic to aggresive minification', (options, em) ->
  em.emit 'log', 'Run html-minifier on the HTML with standard options'

  gem.once 'end:mkdirs', ->
    # get the file to min
    em.emit 'log', "Run on #{file.pages.default.include}"

    process.chdir path.join(base, dir.intermediate)
    helper.fileset "#{file.pages.default.include}", (err, pages) ->
      return error err if err

      remaining = pages.length
      for page in pages then do (page) ->
       fs.readFile page, 'utf8', (err, body) ->
        return error err if err

        # todo: move the configuration over to config files
        # going with most aggresive minification for now

        output = htmlmin.minify body, {
          removeComments: true
          removeCommentsFromCDATA: true
          removeEmptyAttributes: true
          cleanAttributes: true
          removeAttributeQuotes: true
          removeRedundantAttributes: true
          removeScriptTypeAttributes: true
          removeStyleLinkTypeAttributes: true
          collapseWhitespace: true

          # tests no longer pass when set to true, stripping some scripts
          # removeEmptyElements: true
          collapseBooleanAttributes: true
          removeOptionalTags: true
        }

        fs.writeFile page, output, (err) ->
          return error err if err
          em.emit 'end' if --remaining is 0

  invoke 'mkdirs'

