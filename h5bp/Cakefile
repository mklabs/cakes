# `cake` is a simplified version of [Make](http://www.gnu.org/software/make/)
# ([Rake](http://rake.rubyforge.org/), [Jake](http://github.com/280north/jake))
# for CoffeeScript. You define tasks with names and descriptions in a Cakefile,
# and can call them from the command line, or invoke them from other tasks.
#
# Running `cake` with no arguments will print out a list of all the tasks in the
# current directory's Cakefile.
#
# TODO:
# * break the script in smaller parts
#
#   * js
#   * css
#   * html
#   * img
#   * lint
#

# External dependencies.
fs              = require 'fs'
path            = require 'path'
{EventEmitter}  = require 'events'
vm              = require 'vm'
colors          = require 'colors'
coffee          = require 'coffee-script'
config          = require './conf/default'
extend          = require('./tasks/util/helper').extend

# options parsing, to be able to parse command line arguments and used them outside of a cake task
# mainly for the loglevel options
options = require './tasks/util/options'

# setup logger
log = require('./tasks/util/log')(options)

# merge the local config with global object for this module,
# so that interpolation works as expected (todo: calrify configuration)
extend global, config

# the event emitter used along tasks to handle some asynchronous stuff, gem for global EventEmitter
gem = new EventEmitter

# ### task monkey-patch
#
# to provide a tasks-scopped EventEmitter to enable some async stuff and task ordering
#
_task = global.task

# internal _tasks cache, stored as `taskname: status` where status turns false
# once the end event is emitted
_tasks = {}

task = (name, description, action) ->

  description = description.grey
  _task name, description, (options) ->
    em = new EventEmitter()
      # provide a few logging helpers
      .on('error', (err) -> log.error 'error occured'.red.bold; error err)
      .on('warn', (err) -> log.warn err)
      .on('log', log.input.bind log, "#{name} » ".magenta)
      .on('data', log.inspect.bind log)
      .on('end', (results) ->
        log.info  "✔ end:#{name}".green
        log.silly log.inspector(results)
        gem.emit "end:#{name}", results
        _tasks[name] = 'done'
      )

    state = _tasks[name]

    # emit the end event and prevent action call if the task is
    # already done
    return gem.emit "end:#{name}" if state is 'done'

    # set the task state to pending, will turn done once the task emiter
    # emit the end event
    _tasks[name] = 'pending'

    log.verbose "start #{name}  » ".grey
    # invoke the task if the task is unknown yet
    action.call @, options, em unless state


# error handler, usage:
#
#     return error err if err
#
#     return error new Error(':((') if err
error = (err) ->
  log.error '  ✗ '.red + (err.message || err).red
  process.exit 1

#
# Autoload tasks in tasks/
#
fs.readdirSync(path.join(__dirname, 'tasks'))
  .filter((file) -> fs.statSync(path.join(__dirname, 'tasks', file)).isFile())
  .forEach (file) ->
    script = fs.readFileSync path.join(__dirname, 'tasks', file), 'utf8'
    # tasks may be written in pure JS or coffee. Take care of coffee compile if needed.
    script = if /\.coffee$/.test(file) then coffee.compile script else script
    # merge the globals for console, process etc
    context = extend {}, global
    # and setup a few local variable to be available in context
    extend context, 
      task: task
      require: require
      error: error
      gem: gem
      __filename: file
      __dirname: path.dirname path.join(__dirname, 'tasks', file)

    vm.runInNewContext script, context, file



# ### manifest
# stumb method for now.

task 'manifest', 'Manifest stuff', (options, em) ->


